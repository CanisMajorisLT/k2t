{"version":3,"sources":["statistics_calculation_functions.js"],"names":[],"mappings":"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","file":"statistics_calculation_functions-compiled.js","sourcesContent":["/**\r\n * Created by vyt on 2015-08-11.\r\n */\r\nlet trimAndRemoveSigns = require(\"../utils\").trimAndRemoveSigns;\r\n\r\n\r\nlet calculateWPM = exports.calculateWPM = (startTime, finishTime, textLengthInWords) => {\r\n    if (!startTime || !finishTime || !textLengthInWords) {\r\n        return 0\r\n    }\r\n    return (textLengthInWords / ((finishTime - startTime) / 1000)) * 60\r\n};\r\n\r\n/**@param {object) wordsStatsArray from StatsObj.wordStats\r\n * @return {object} {totalMistakesInText: 0, words: {word(str): {count: 0, mistakes: 0, heatMap: [], typingTime: {all: [], fastest: null}}}}*/\r\nlet wordsStatisticsCalculator_deprected = exports.wordsStatisticsCalculator_deprected = (wordsStatsArray, trimAndClean=true) => {\r\n    return wordsStatsArray\r\n        .map((singleWordStatsArray) => {\r\n            return singleWordStats(singleWordStatsArray, trimAndClean=true)\r\n        })\r\n        .reduce((accumulated, eachTextWordStatsObject) => {\r\n            let word = eachTextWordStatsObject.word;\r\n            let heatMap = eachTextWordStatsObject.heatMap;\r\n            let tempTotalMistakesInText = accumulated.totalMistakesInText + eachTextWordStatsObject.mistakes;\r\n            if (!accumulated.words.hasOwnProperty(word)) {\r\n                accumulated.words[word] = {count: 0, mistakes: 0, heatMap: [], typingTime: {all: [], fastest: null}}\r\n            }\r\n\r\n            accumulated.words[word].mistakes += eachTextWordStatsObject.mistakes;\r\n            accumulated.words[word].count += 1;\r\n            let FastestTypingTime = accumulated.words[word].typingTime.fastest;\r\n            if (!FastestTypingTime || FastestTypingTime < eachTextWordStatsObject.typingTime) {\r\n                accumulated.words[word].typingTime.fastest = eachTextWordStatsObject.typingTime\r\n            }\r\n            accumulated.words[word].typingTime.all.push(eachTextWordStatsObject.typingTime);\r\n\r\n            if (accumulated.words[word].heatMap.length === 0) {\r\n                accumulated.words[word].heatMap = heatMap\r\n            }\r\n            else {\r\n                accumulated.words[word].heatMap.map((mistake, index) => {\r\n                    let mistake2 = heatMap[index];\r\n                    if (!mistake && !mistake2) {\r\n                        return undefined\r\n                    }\r\n                    else {\r\n                        return mistake + mistake2\r\n                    }\r\n                });\r\n            }\r\n\r\n\r\n            return {totalMistakesInText: tempTotalMistakesInText, words: accumulated.words}\r\n\r\n        }, {totalMistakesInText: 0, words: {}});\r\n\r\n\r\n};\r\n\r\n/**@param {object) wordsStatsArray from StatsObj.wordStats\r\n * @return {object} {totalMistakesInText: 0, words: [singleWordStats, singleWordStats, {object} {word: str, mistakes: number, heatMap: [], typingTime: number}]}*/\r\nlet wordsStatisticsCalculator = exports.wordsStatisticsCalculator = (wordsStatsArray, trimAndClean=true) => {\r\n//TODO: prpalesti jsona, ideti mistakes mapa, word mapa\r\n    return wordsStatsArray\r\n        .map((singleWordStatsArray) => {\r\n            return singleWordStats(singleWordStatsArray, trimAndClean=true)\r\n        })\r\n        .reduce((accumulated, eachTextWordStatsObject) => {\r\n            let tempTotalMistakesInText = accumulated.totalMistakesInText + eachTextWordStatsObject.mistakes;\r\n            accumulated.words.push(eachTextWordStatsObject);\r\n            return {totalMistakesInText: tempTotalMistakesInText, words: accumulated.words}\r\n\r\n        }, {totalMistakesInText: 0, words: []});\r\n\r\n\r\n};\r\n\r\n\r\n/**\r\n * @return {object} {word: str, mistakes: number, heatMap: [], typingTime: number}\r\n * */\r\nlet singleWordStats = exports.singleWordStats = (singleWordArray, trimAndClean=true) => {\r\n    return singleWordArray.reduce((accumulated, currentWordStatsObj, index, array) => {\r\n        var word = trimAndClean ? trimAndRemoveSigns(currentWordStatsObj.word) : currentWordStatsObj.word;\r\n        if (!accumulated.word) {\r\n            accumulated.word = word;\r\n        }\r\n        if (accumulated.heatMap.length === 0) {\r\n            accumulated.heatMap = new Array(word.length)\r\n        }\r\n\r\n        if (currentWordStatsObj.matches === false) {\r\n            ++accumulated.mistakes;\r\n\r\n            let heatMapCoord = accumulated.heatMap[currentWordStatsObj.input.length - 1];\r\n            if (!heatMapCoord) {\r\n                accumulated.heatMap[currentWordStatsObj.input.length - 1] = 1\r\n            }\r\n            else {\r\n                ++accumulated.heatMap[currentWordStatsObj.input.length - 1]\r\n            }\r\n        }\r\n        if (index === 0) {\r\n            accumulated.typingTime.tempStart = currentWordStatsObj.time\r\n        }\r\n        if (index === array.length - 1) {\r\n            let start = accumulated.typingTime.tempStart;\r\n            accumulated.typingTime = currentWordStatsObj.time - start\r\n        }\r\n\r\n        return accumulated\r\n    }, {word: null, mistakes: 0, heatMap: [], typingTime: {tempStart: 0, tempEnd: 0}})\r\n};\r\n\r\n"]}